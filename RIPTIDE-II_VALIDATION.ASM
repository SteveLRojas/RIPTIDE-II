; THIS PROGRAM WILL TEST VARIOUS FUNCTIONS OF THE RIPTIDE-II CPU, AND POST RESULTS AT CERTAIN MEMORY LOCATIONS.
; AFTER ALL TESTS ARE COMPLETED A PORTION OF THE DATA MEMORY IS DUMPED THROUGH A SERIAL PORT.

; MEM DUMP LOCATIONS:
; $00 HAZARD TEST OVF RESULT	EXPECTED: $00
; $01 HAZARD TEST XMIT RESULT 	EXPECTED: $FF
; $02 XEC TEST CLEAR RESULT 	EXPECTED: $00
; $03 XEC TEST SET RESULT		EXPECTED: $FF
; $04 XEC TEST BRANCH PASS/FAIL	EXPECTED: $AA
; $05 XEC IV TEST RESULT		EXPECTED: $00
; $06 XEC IV TEST RESULT		EXPECTED: $FF
; $07 CALL NOP RESULT			EXPECTED: $AA
; $08 CALL SHORT RESULT			EXPECTED: $AA
; $09 CALL RECURSIVE RESULTS	EXPECTED: $07
; $0A		EXPECTED: $06
; $0B		EXPECTED: $05
; $0C		EXPECTED: $04
; $0D		EXPECTED: $03
; $0E		EXPECTED: $02
; $0F		EXPECTED: $01
; $10		EXPECTED: $00
; $11 CALL TEST DONE RESULT		EXPECTED: $AA
; $12 XEC IV TEST INTERMEDIATE RESULT	EXPECTED: $00
; $13 XEC IV TEST INTERMEDIATE RESULT	EXPECTED: $01
; $14 FAST WRITE RESULT		EXPECTED: $07
; $15 FAST WRITE RESULT		EXPECTED: $07
; $16 FAST WRITE RESULT		EXPECTED: $05
; $17 FAST WRITE RESULT		EXPECTED: $0F
; $18 FAST WRITE RESULT		EXPECTED: $0E

; STATUS CODES:
; $0000		RESET VALUE
; $0001		PROGRAM EXECUTION STARTED
; $0002		PAGE SELECTED, DATA CACHE RESET, AND STACK CONFIGURED
; $0003		INITIAL MINI DUMP COMPLETED
; $0004		FAST_WRITE STARTED
; $0005		LONG_JUMP STARTED
; $0105		LONG_JUMP COMPLETED
; $0106		XEC_IV_TEST STARTED
; $0107		XEC_TEST STARTED
; $0108		HAZARD_TEST STARTED
; $0109		CALL_TEST STARTED
; $010A		SECOND MINI DUMP COMPLETED
; $010B		DISPLAY_INIT COMPLETED

;Address map for left bank:
; 0x0000 to 0x0FFF video memory (read write)
; 0x1000 to 0xFFF5	unused
; 0xFFF6 to 0xFFF7 video mode register (write only)
; 0xFFF8 to 0xFFFB memory subsystem control registers	(write only)
; 0xFFFC to 0xFFFD	LED register	(write only)
; 0xFFFE to 0xFFFF	RS-232 module	(read write)

; MSC Address map
; 0x0 program space control register
; 	bit0	reset bit (LSB)
; 	bit1	reserved
; 	bit2	reserved
; 	bit3	control enable bit
; 0x1 program space page register
; 0x2 data space control register
; 	bit0	reset bit (LSB)
; 	bit1	flush bit
; 	bit2	reserved
; 	bit3	control enable bit
; 0x3 data space page register

; RS-232 module address map
; 0 data register
; 1 status register
;	bit0	tx_overwrite bit (LSB)
;	bit1	rx_overwrite bit
;	bit2	tx_done bit
;	bit3	rx_done bit

; Address map for right bank:
; 0x0000 to 0xFFFF	active data memory page (cached)

; Address map for program space:
; 0x0000 to 0xFFFF	active program memory page (cached)

; REMEMBER: PROGRAM MEMORY IS WORD ADDRESSABLE WHILE DATA MEMORY IS BYTE ADDRESSABLE!
; THE TWO MEMORY SPACES ARE SHARED THROUGH THE CACHE CONTROLLERS, BOTH CACHES MUST BE FLUSHED FOR CHANGES TO THE DATA SPACE TO SHOW UP IN THE PROGRAM SPACE.

INCLUDE "8X-RIPTIDE.INC"
; THESE ARE ADDRESSES OF MEMORY LOCATIONS USED FOR SPECIAL PURPOSES IN THE PROGRAM
DUMP_START_LOW		EQU $F000
DUMP_START_HIGH		EQU $F001
DUMP_END_LOW		EQU $F002
DUMP_END_HIGH		EQU $F003

R0_SAVE_LOC		EQU $F004
AUX_SAVE_LOC	EQU $F004
R1_SAVE_LOC		EQU $F005
R2_SAVE_LOC		EQU $F006
R3_SAVE_LOC		EQU $F007
R4_SAVE_LOC		EQU $F008
R5_SAVE_LOC		EQU $F009
R6_SAVE_LOC		EQU $F00A
R11_SAVE_LOC	EQU $F00B

STACK_LOW	EQU $F00C
STACK_HIGH	EQU $F00D	;THESE LOCATIONS HOLD THE STARTING ADDRESS OF THE STACK
STACK_TOP_LIMIT_LOW		EQU $F00E
STACK_TOP_LIMIT_HIGH	EQU $F00F	;THESE LOCATIONS HOLD THE LOWEST ADDRESS THE STACK CAN REACH. THE STACK GROWS DOWN.
STACK_BASE_LIMIT_LOW	EQU $F010
STACK_BASE_LIMIT_HIGH	EQU $F011	;THESE LOCATIONS HOLD THE HIGHEST ADDRESS THE STACK CAN REACH. THIS SHOULD ALSO BE THE STACK INITIAL ADDRESS.

	ORG 0
INIT
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $01, LIV7, 4	;SET HEX LOW
	XMIT $FF, IVL
	XMIT $FD, IVR
	XMIT $00, LIV7, 8	;SET HEX HIGH

	XMIT $00, AUX
	XMIT $00, R1
	XMIT $00, R2
	XMIT $00, R3
	XMIT $00, R4
	XMIT $00, R5
	XMIT $00, R6
	XMIT $00, R11	;INITIALIZE REGISTERS

	XMIT $FF, IVL
	XMIT $F8, IVR
	XMIT $08, LIV7, 8	;ENABLE PROGRAM CACHE CONTROL

	XMIT $FA, IVR
	XMIT $08, LIV7, 8	;ENABLE DATA CACHE CONTROL

	XMIT $FB, IVR
	XMIT $01, LIV7, 8	;SWITCH TO DATA PAGE 1

	XMIT $FA, IVR
	XMIT $09, LIV7, 8	;RESET DATA CACHE AND KEEP CONTROL ENABLED

	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	MOVE RIV7, 8, AUX	;HOLD UNTIL RESET IS DONE

	XMIT `HIGH STACK_INIT, AUX
	CALL STACK_INIT

	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $02, LIV7, 4	;SET HEX LOW

	XMIT `HIGH MINI_DUMP_REPLACER, AUX
	CALL MINI_DUMP_REPLACER

	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $03, LIV7, 4	;SET HEX LOW

	;JMP FAST_WRITE
	JMP LONG_JUMP

	ORG $40
XEC_IV_TEST
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $06, LIV7, 4	;SET HEX LOW

	XMIT $AA, R0
;SET DATA ADDRESS TO RAM LOCATION
	XMIT $00, IVL
	XMIT $12, IVR
	XMIT $00, RIV3, 4
	XMIT $00, RIV7, 4	;CLEAR RIV
	XEC CLR_R0 (RIV7, 4)
;POST RESULT
	XMIT $00, IVL
	XMIT $05, IVR
	MOVE R0, 8, RIV7

	XMIT $00, IVL
	XMIT $13, IVR
	XMIT $01, RIV7, 8	;SET RIV TO 1
	XEC CLR_R0 (RIV7, 4)
;POST RESULT
	XMIT $00, IVL
	XMIT $06, IVR
	MOVE R0, 8, RIV7
	JMP XEC_TEST

CLR_R0
	XMIT $00, R0
SET_R0
	XMIT $FF, R0

CALL_TEST
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $09, LIV7, 4	;SET HEX LOW

	XMIT `HIGH SUB_NOP, AUX
	CALL SUB_NOP
	NOP
	NOP
	CALL SUB_SHORT
;POST RESULT
	XMIT $00, IVL
	XMIT $08, IVR
	XMIT $AA, R3
	MOVE R3, 8, RIV7
	XMIT 8, R1
	XMIT $09, R4	;INITIALIZE ADDRESS COUNTER FOR POSTING RESULTS
	CALL SUB_NESTED
SUB_NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
;POST RESULT
	XMIT $00, IVL
	XMIT $07, IVR
	XMIT $AA, R3
	MOVE R3, 8, RIV7
	RET
SUB_SHORT
	RET
SUB_NESTED
	MOVE AUX, R2	;COPY AUX TO R2
	XMIT $FF, AUX	;SET AUX TO -1
	ADD R1, R1	;DECREMENT R1

	XMIT $00, IVL
	MOVE R4(0), IVR
	MOVE R1, 8, RIV7
	XMIT $01, AUX
	ADD R4, R4

	MOVE R2, AUX	;RESTORE AUX
	NZT R1, SN_NEXT	;IF R1 NOT ZERO CALL SUB_NESTED AGAIN
	RET
SN_NEXT
	CALL SUB_NESTED
;POST RESULT
	XMIT $00, IVL
	XMIT $11, IVR
	XMIT $AA, R5
	MOVE R5, 8, RIV7
	XMIT `HIGH MINI_DUMP_REPLACER, AUX
	CALL MINI_DUMP_REPLACER
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $0A, LIV7, 4	;SET HEX LOW
	XMIT `HIGH DISPLAY_INIT_CG3, AUX
	CALL DISPLAY_INIT_CG3
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $0B, LIV7, 4	;SET HEX LOW
	JMP MAIN

SAVE_ALL
	XMIT `HIGH AUX_SAVE_LOC, IVL
	XMIT `LOW AUX_SAVE_LOC, IVR
	MOVE AUX, 8, RIV7

	XMIT `HIGH R1_SAVE_LOC, IVL
	XMIT `LOW R1_SAVE_LOC, IVR
	MOVE R1, 8, RIV7

	XMIT `HIGH R2_SAVE_LOC, IVL
	XMIT `LOW R2_SAVE_LOC, IVR
	MOVE R2, 8, RIV7

	XMIT `HIGH R3_SAVE_LOC, IVL
	XMIT `LOW R3_SAVE_LOC, IVR
	MOVE R3, 8, RIV7

	XMIT `HIGH R4_SAVE_LOC, IVL
	XMIT `LOW R4_SAVE_LOC, IVR
	MOVE R4, 8, RIV7

	XMIT `HIGH R5_SAVE_LOC, IVL
	XMIT `LOW R5_SAVE_LOC, IVR
	MOVE R5, 8, RIV7

	XMIT `HIGH R6_SAVE_LOC, IVL
	XMIT `LOW R6_SAVE_LOC, IVR
	MOVE R6, 8, RIV7

	XMIT `HIGH R11_SAVE_LOC, IVL
	XMIT `LOW R11_SAVE_LOC, IVR
	MOVE R11, 8, RIV7
	RET

RESTORE_ALL
	XMIT `HIGH AUX_SAVE_LOC, IVL
	XMIT `LOW AUX_SAVE_LOC, IVR
	MOVE RIV7, 8, AUX

	XMIT `HIGH R1_SAVE_LOC, IVL
	XMIT `LOW R1_SAVE_LOC, IVR
	MOVE RIV7, 8, R1

	XMIT `HIGH R2_SAVE_LOC, IVL
	XMIT `LOW R2_SAVE_LOC, IVR
	MOVE RIV7, 8, R2

	XMIT `HIGH R3_SAVE_LOC, IVL
	XMIT `LOW R3_SAVE_LOC, IVR
	MOVE RIV7, 8, R3

	XMIT `HIGH R4_SAVE_LOC, IVL
	XMIT `LOW R4_SAVE_LOC, IVR
	MOVE RIV7, 8, R4

	XMIT `HIGH R5_SAVE_LOC, IVL
	XMIT `LOW R5_SAVE_LOC, IVR
	MOVE RIV7, 8, R5

	XMIT `HIGH R6_SAVE_LOC, IVL
	XMIT `LOW R6_SAVE_LOC, IVR
	MOVE RIV7, 8, R6

	XMIT `HIGH R11_SAVE_LOC, IVL
	XMIT `LOW R11_SAVE_LOC, IVR
	MOVE RIV7, 8, R11
	RET

BIG_DUMP
; LOAD END ADDRESS AND MAKE IT NEGATIVE
	XMIT `HIGH DUMP_END_HIGH, IVL
	XMIT `LOW DUMP_END_HIGH, IVR
	MOVE RIV7, 8, R1

	XMIT `HIGH DUMP_END_LOW, IVL
	XMIT `LOW DUMP_END_LOW, IVR
	MOVE RIV7, 8, R2

	XMIT $FF, AUX
	XOR R1, R1
	XOR R2, R2

	XMIT $01, AUX	;WE MAKE THE HIGH AND LOW PARTS NEGATIVE, NOT THE WHOLE THING.
	ADD R2, R2		;THIS IS BECAUSE WE COMPARE IT BY PARTS.
	ADD R1, R1
; LOAD START ADDRESS
	XMIT `HIGH DUMP_START_HIGH, IVL
	XMIT `LOW DUMP_START_HIGH, IVR
	MOVE RIV7, 8, R5

	XMIT `HIGH DUMP_START_LOW, IVL
	XMIT `LOW DUMP_START_LOW, IVR
	MOVE RIV7, 8, R6
BD_LOOP
; READ DATA FROM MEMORY
	MOVE R5, IVL
	MOVE R6, IVR
	MOVE RIV7, 8, R4
; CHECK THAT UART IS READY
	XMIT $FF, IVL
	XMIT $FF, IVR
BD_WAIT
	XMIT $01, AUX
	MOVE LIV5, 1, R3
	XOR R3, R3
	NZT R3, BD_WAIT
	XMIT $FF, IVL
	XMIT $FE, IVR
	MOVE R4, 8, LIV7
; ADD 1 TO ADDRESS
	ADD R6, R6
	MOVE OVF, AUX
	ADD R5, R5
; COMPARE HIGH ADDRESS
	MOVE R5, AUX
	ADD R1, R3
	NZT R3, BD_LOOP
; COMPARE LOW ADDRESS
	MOVE R6, AUX
	ADD R2, R3
	NZT R3, BD_LOOP
	RET

MINI_DUMP_REPLACER
; CONFIGURE DUMP
	XMIT `HIGH DUMP_END_HIGH, IVL
	XMIT `LOW DUMP_END_HIGH, IVR
	XMIT $00, RIV7, 8
	XMIT `HIGH DUMP_END_LOW, IVL
	XMIT `LOW DUMP_END_LOW, IVR
	XMIT $02, RIV3, 4
	XMIT $00, RIV7, 4	;DUMP END VARS NOW CONTAIN $0020

	XMIT `HIGH DUMP_START_HIGH, IVL
	XMIT `LOW DUMP_START_HIGH, IVR
	XMIT $00, RIV7, 8
	XMIT `HIGH DUMP_START_LOW, IVL
	XMIT `LOW DUMP_START_LOW, IVR
	XMIT $00, RIV7, 8	;DUMP START VARS NOW CONTAIN $0000
; CALL BIG DUMP AND GO TO NEXT TARGET
	XMIT `HIGH BIG_DUMP, AUX
	CALL BIG_DUMP
	RET

; PADDING FOR ALIGNING BRANCH BOUNDARIES
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

SERIAL_GET_BYTE
; CHECK THAT UART IS READY
	XMIT $FF, IVL
	XMIT $FF, IVR
SGB_WAIT
	XMIT $01, AUX
	MOVE LIV4, 1, R11 	;READ TX READY BIT
	XOR R11, R11 			;INVERT TX READY BIT
	NZT R11, SGB_WAIT	;IF TX NOT READY KEEP WAITING
	XMIT $FE, IVR
	MOVE LIV7, 8, R11
	RET

SERIAL_SEND_BYTE
; CHECK THAT UART IS READY
	XMIT $FF, IVL
	XMIT $FF, IVR
SSB_WAIT
	XMIT $01, AUX
	MOVE LIV5, 1, R11
	XOR R11, R11
	NZT R11, SSB_WAIT
	XMIT $FE, IVR
	MOVE R11, 8, LIV7
	RET

XEC_TEST
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $07, LIV7, 4	;SET HEX LOW

	XMIT $55, R2
	XMIT $00, R0
	XEC CLR_R2 (AUX)
; POST FIRST RESULT
	XMIT $00, IVL
	XMIT $02, IVR
	MOVE R2, 8, RIV7

	XMIT $01, R0
	XEC CLR_R2 (AUX)
; POST SECOND RESULT
	XMIT $00, IVL
	XMIT $03, IVR
	MOVE R2, 8, RIV7

	XMIT $02, R0
	XEC CLR_R2 (AUX)
; POST TEST FAILED
	XMIT $00, IVL
	XMIT $04, IVR
	XMIT $FF, R2
	MOVE R2, 8, RIV7
	JMP NOP_TEST	;HALT CPU

XEC_BRANCH_RETURN
; POST TEST PASSED
	XMIT $00, IVL
	XMIT $04, IVR
	XMIT $AA, R2
	MOVE R2, 8, RIV7
	JMP HAZARD_TEST

CLR_R2
	XMIT $00, R2
SET_R2
	XMIT $FF, R2
XEC_BRANCH
	JMP XEC_BRANCH_RETURN
	
NOP_TEST
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	JMP NOP_TEST

HAZARD_TEST_POST
	XMIT $00, IVL
	XMIT $00, IVR	;SET DATA ADDRESS TO $0000
	MOVE OVF, 8, RIV7
	XMIT $01, IVR
	MOVE R1, 8, RIV7
	JMP CALL_TEST

HAZARD_TEST2
	NOP
	NOP
	NOP
	NOP
	NZT AUX, HAZARD_TEST_POST
	XMIT $EE, R1	;R1 SHOULD REMAIN SET

HAZARD_TEST
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $08, LIV7, 4	;SET HEX LOW

	XMIT $00, R6
	XMIT $00, AUX
	ADD R6, R6	;CLEAR OVF
	XMIT $FF, R1
	XMIT $01, AUX	;WILL ADD THESE TWO TO CAUSE AN OVERFLOW
	NZT R1, HAZARD_TEST2	;CONDITIONAL BRANCH TO FLUSH PIPELINE
	ADD R1, R1	;OVF SHOULD NOT BE SET
	NOP
	NOP
	NOP
	NOP

FAST_WRITE
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $04, LIV7, 4	;SET HEX LOW

	XMIT $DF, IVL
	XMIT $FF, IVR
	XMIT $05, RIV7, 8
	NOP
	NOP
	XMIT $FF, IVL
	XMIT $FF, IVR
	XMIT $00, RIV7, 8
	XMIT $01, RIV7, 8
	XMIT $02, RIV7, 8
	XMIT $03, RIV7, 8
	XMIT $04, RIV7, 8
	XMIT $05, RIV7, 8
	XMIT $06, RIV7, 8
	XMIT $07, RIV7, 8
	XMIT $EF, IVL
	XMIT $00, RIV7, 8
	XMIT $01, RIV7, 8
	XMIT $02, RIV7, 8
	XMIT $03, RIV7, 8
	XMIT $04, RIV7, 8
	XMIT $05, RIV7, 8
	XMIT $06, RIV7, 8
	XMIT $07, RIV7, 8
	XMIT $DF, IVL
	XMIT $CF, IVL
	XMIT $0F, RIV7, 8
	XMIT $BF, IVL
	XMIT $0E, RIV7, 8
	NOP
	NOP
; POST RESULTS
	XMIT $FF, IVL
	XMIT $FF, IVR	;SET DATA ADDRESS TO $FFFF
	MOVE RIV7, 8, AUX	;PUT RESULT IN AUX
	XMIT $00, IVL
	XMIT $14, IVR	;POST AT THIS ADDRESS
	MOVE AUX, 8, RIV7

	XMIT $EF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $15, IVR
	MOVE AUX, 8, RIV7

	XMIT $DF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $16, IVR
	MOVE AUX, 8, RIV7

	XMIT $CF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $17, IVR
	MOVE AUX, 8, RIV7

	XMIT $BF, IVL
	XMIT $FF, IVR
	MOVE RIV7, 8, AUX
	XMIT $00, IVL
	XMIT $18, IVR
	MOVE AUX, 8, RIV7
	JMP LONG_JUMP

LONG_JUMP
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $00, LIV3, 4
	XMIT $05, LIV7, 4	;SET HEX LOW

	XMIT $00, IVL
	XMIT $31, IVR
	XMIT $0A, RIV3, 4
	XMIT $0F, RIV7, 4
	XMIT $30, IVR
	XMIT $00, RIV7, 8	;CREATE RET INSTRUCTION AT ADDRESS $8018 IN PROGRAM SPACE ($10031 AND $10030 IN DATA SPACE)

	XMIT $FF, IVL
	XMIT $FA, IVR
	XMIT $0A, LIV7, 8	;FLUSH DATA CACHE AND KEEP CONTROL ENABLED

	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP

	XMIT $EF, IVL
	MOVE RIV7, 8, AUX	;WAIT FOR CACHE FLUSH TO COMPLETE

	XMIT $80, AUX		;SET PAGE REGISTER TO $80
	CALL $18	;CALL ADDRESS $8018
	
	XMIT $FF, IVL
	XMIT $FD, IVR
	XMIT $01, LIV7, 8	;SET HEX HIGH
	JMP XEC_IV_TEST

STACK_PUSH
; GET CURRENT STACK ADDRESS
	XMIT `HIGH STACK_LOW, IVL
	XMIT `LOW STACK_LOW, IVR
	XMIT $FF, AUX
	MOVE RIV7, 8, R1
	XMIT `HIGH STACK_HIGH, IVL
	XMIT `LOW STACK_HIGH, IVL
	MOVE RIV7, 8, R2
; WRITE DATA TO STACK
	MOVE R2, IVL
	MOVE R1, IVR
	MOVE R11, 8, RIV7
; DECREMENT STACK ADDRESS
	ADD R2, R2
	ADD R1, R1
	MOVE OVF, AUX
	ADD R2, R2
; SAVE DECREMENTED ADDRESS
	XMIT `HIGH STACK_LOW, IVL
	XMIT `LOW STACK_LOW, IVR
	MOVE R1, 8, RIV7
	XMIT `HIGH STACK_HIGH, IVL
	XMIT `LOW STACK_HIGH, IVL
	MOVE R2, 8, RIV7
	RET

STACK_POP
; GET CURRENT STACK ADDRESS
	XMIT `HIGH STACK_LOW, IVL
	XMIT `LOW STACK_LOW, IVR
	XMIT $01, AUX
	MOVE RIV7, 8, R1
	XMIT `HIGH STACK_HIGH, IVL
	XMIT `LOW STACK_HIGH, IVL
	MOVE RIV7, 8, R2
; INCREMENT ADDRESS
	ADD R1, R1
	MOVE OVF, AUX
	ADD R2, R2
; READ DATA FROM STACK
	MOVE R2, IVL
	MOVE R1, IVR
	MOVE RIV7, 8, R11
; SAVE INCREMENTED ADDRESS
	XMIT `HIGH STACK_LOW, IVL
	XMIT `LOW STACK_LOW, IVR
	MOVE R1, 8, RIV7
	XMIT `HIGH STACK_HIGH, IVL
	XMIT `LOW STACK_HIGH, IVL
	MOVE R2, 8, RIV7
	RET

MINI_DUMP
	XMIT $00, R1	;INITIALIZE ADDRESS COUNTER
	XMIT $20, R2	;END ADDRESS
	XMIT $FF, AUX
	XOR R2, R2
	XMIT $01, AUX
	ADD R2, R2		;R2 NOW CONTAINS -32
MD_LOOP
;READ DATA FROM MEMORY
	XMIT $00, IVL
	MOVE R1, IVR
	MOVE RIV7, 8, R4
;CHECK THAT UART IS READY
	XMIT $FF, IVL
	XMIT $FF, IVR	;UART STATUS REGISTER
MD_WAIT
	XMIT $01, AUX
	MOVE LIV5, 1, R5 	;READ TX READY BIT
	XOR R5, R5 			;INVERT TX READY BIT
	NZT R5, MD_WAIT			;IF TX NOT READY KEEP WAITING
	XMIT $FF, IVL
	XMIT $FE, IVR 		;UART DATA REGISTER
	MOVE R4, 8, LIV7
;ADD 1 TO ADSRESS
	XMIT $01, AUX
	ADD R1, R1
	MOVE R2, AUX	;SET AUX TO -32
	ADD R1, R3	;SUBTRACT 32 FROM ADDRESS
	NZT R3, MD_LOOP	;IF ADDRESS != 32 DO NEXT ADDRESS
	XMIT $FF, IVL
	XMIT $FC, IVR
	XMIT $0E, LIV3, 4
	XMIT $0F, LIV7, 4	;TURN ON LEDs
	JMP NOP_TEST	;ELSE END

STACK_IS_EMPTY
	XMIT $00, R11
	XMIT `HIGH STACK_LOW, IVL
	XMIT `LOW STACK_LOW, IVR
	MOVE RIV7, 8, AUX	;GET STACK LOW ADDRESS

	XMIT `HIGH STACK_BASE_LIMIT_LOW, IVL
	XMIT `LOW STACK_BASE_LIMIT_LOW, IVR
	XOR RIV7, 8, AUX	;GET BASE LIMIT LOW ADDRESS AND COMPARE WITH STACK LOW ADDRESS
	NZT AUX, SIE_FALSE	;IF THEY ARE NOT EQUAL RETURN FALSE

	XMIT `HIGH STACK_HIGH, IVL
	XMIT `LOW STACK_HIGH, IVR
	MOVE RIV7, 8, AUX	;GET STACK HIGH ADDRESS

	XMIT `HIGH STACK_BASE_LIMIT_HIGH, IVL
	XMIT `LOW STACK_BASE_LIMIT_HIGH, IVR
	XOR RIV7, 8, AUX	;GET BASE LIMIT HIGH ADDRESS AND COMPARE WITH STACK HIGH ADDRESS
	NZT AUX, SIE_FALSE	;IF THEY ARE NOT EQUAL RETURN FALSE

	XMIT $01, R11	;ELSE RETURN TRUE
SIE_FALSE
	RET

DISPLAY_INIT_SG4
;SET ALL CHARS TO 0X60
;32 * 16 = 512 CHARS
	XMIT $00, R1	;LOW COUNTER
	XMIT $00, R2	;HIGH COUNTER
	XMIT $01, AUX	;IMPLICIT OPERAND FOR INCREMENTS
DI_LOOP
	MOVE R2, IVL
	MOVE R1, IVR
	XMIT $06, LIV3, 4
	XMIT $00, LIV7, 4
	ADD R1, R1
	NZT R1, DI_LOOP
	NZT R2, DI_DONE
	ADD R2, R2
	JMP DI_LOOP
DI_DONE
	RET

DISPLAY_INIT_CG3
;SET ALL DISPLAY ELEMENTS TO 3 (RED)
;4 ELEMENTS PER BYTE; SET ALL BYTES TO 0XFF
;128 * 96 / 4 = 3072 BYTES
;TWO LOOPS; 12 * 256 = 3072
	XMIT $FF, IVL
	XMIT $F7, IVR	;VIDEO MODE REGISTER ADDRESS
	XMIT $01, LIV7, 1	;SET VIDEO MODE TO COLOR GRAPHICS 3
	XMIT $00, R1	;LOW COUNTER
	XMIT 12, R2		;HIGH COUNTER
	XMIT $FF, AUX	;IMPLICIT OPERAND FOR DECREMENTS
DI_CG3_LOOP
	ADD R2, IVL	;R2 - 1 -> IVL
	ADD R1, IVR	;R1 - 1 -> IVR
	XMIT $0F, LIV3, 4
	XMIT $0F, LIV7, 4
	ADD R1, R1
	NZT R1, DI_CG3_LOOP
	ADD R2, R2
	NZT R2, DI_CG3_LOOP
	RET

STACK_INIT
	XMIT `HIGH STACK_LOW, IVL
	XMIT `LOW STACK_LOW, IVR
	XMIT $0F, RIV3, 4
	XMIT $0F, RIV7, 4
	XMIT `HIGH STACK_HIGH, IVL
	XMIT `LOW STACK_HIGH, IVR
	XMIT $0E, RIV3, 4
	XMIT $0F, RIV7, 4	;PLACE STACK

	XMIT `HIGH STACK_TOP_LIMIT_LOW, IVL
	XMIT `LOW STACK_TOP_LIMIT_LOW, IVR
	XMIT $00, RIV7, 8
	XMIT `HIGH STACK_TOP_LIMIT_HIGH, IVL
	XMIT `LOW STACK_TOP_LIMIT_HIGH, IVR
	XMIT $00, RIV7, 8	;PLACE THE STACK TOP LIMIT

	XMIT `HIGH STACK_BASE_LIMIT_LOW, IVL
	XMIT `LOW STACK_BASE_LIMIT_LOW, IVR
	XMIT $0F, RIV3, 4
	XMIT $0F, RIV7, 4
	XMIT `HIGH STACK_BASE_LIMIT_HIGH, IVL
	XMIT `LOW STACK_BASE_LIMIT_HIGH, IVR
	XMIT $0E, RIV3, 4
	XMIT $0F, RIV7, 4	;PLACE THE STACK BASE LIMIT
	RET

MAIN
	XMIT $00, R1	;LOW COUNTER
	XMIT $00, R2	;HIGH COUNTER
	XMIT $0C, R3	;END ADDRESS HIGH
MAIN_LOOP
	XMIT `HIGH SERIAL_GET_BYTE, AUX
	CALL SERIAL_GET_BYTE	;GETS BYTE AND STORES IT IN R11
	XMIT $01, AUX
	MOVE R2, IVL
	MOVE R1, IVR	;SET ADDRESS
	MOVE R11, 8, LIV7	;OUTPUT DATA
	ADD R1, R1	;INCREMENT LOW ADDRESS
	NZT R1, MAIN_LOOP	;IF NOT ZERO LOOP BACK
	ADD R2, AUX
	MOVE AUX, R2	;ELSE INCREMENT HIGH ADDRESS
	XOR R3, AUX	;COMPARE HIGH ADDRESS WITH HIGH END ADDRESS
	NZT AUX, MAIN_LOOP
	JMP MAIN

;NOTE: LABELS ON ORG STATEMENTS CANNOT BE REFERENCED IN THE CODE! THESE DO NOT BELONG TO ANY SEGMENT AND WILL NOT BE FOUND.
STRINGS	ORG $0400
S_STEVE
	XEC STEVE_0 (R1)	;STEVE WAS HERE.
	RET
STEVE_0 XMIT $53, R1
	XMIT $54, R1
	XMIT $45, R1
	XMIT $56, R1
	XMIT $45, R1
	XMIT $20, R1
	XMIT $57, R1
	XMIT $41, R1
	XMIT $53, R1
	XMIT $20, R1
	XMIT $48, R1
	XMIT $45, R1
	XMIT $52, R1
	XMIT $45, R1
	XMIT $2e, R1

	ORG $0FFF	;PAD FILE TO 4K WORDS
	JMP MINI_DUMP