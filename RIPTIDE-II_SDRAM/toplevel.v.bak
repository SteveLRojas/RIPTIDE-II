module PVP(
		input wire reset,
		input wire clk,
		input wire[3:0] button,
		input wire RXD,
		output wire TXD,
		output wire[4:0] LED,

        output wire[1:0] R, G, B,
        output wire HSYNC, VSYNC
		);
//`define EXTERNAL_CPU
//Address map for left bank:
// 0x0000 to 0x0FFF video memory (read write)
// 0x1000 to 0xFFF5	unused
// 0xFFF6 to 0xFFF7 video mode register (write only)
// 0xFFF8 to 0xFFFB memory subsystem control registers	(write only)
// 0xFFFC to 0xFFFD	LED register	(write only)
// 0xFFFE to 0xFFFF	RS-232 module	(read write)

//Address map for right bank:
// 0x0000 to 0xFFFF	active data memory page (cached)

//Address map for program space:
//0x0000 to 0xFFFF	active program memory page (cached)

// MSC Address map
// 0x0 program space control register
// 	bit0	reset bit
// 	bit1	reserved
// 	bit2	reserved
// 	bit3	control enable bit
// 0x1 program space page register
// 0x2 data space control register
// 	bit0	reset bit
// 	bit1	flush bit
// 	bit2	reserved
// 	bit3	control enable bit
// 0x3 data space page register

// RS-232 module address map
// 0 data register
// 1 status register

reg[3:0] button_s;

wire p_cache_miss;
wire[15:0] PRG_address;
wire[15:0] PRG_data;
wire[13:0] p1_address;
wire[63:0] p1_data;
wire p1_reset;
wire p1_req;
wire p1_ready;

p_cache p_cache_inst(
		.clk(clk),
		.rst(p1_reset | button_s[2]),
		.p_cache_miss(p_cache_miss),
		.CPU_address(PRG_address),
		.CPU_data(PRG_data),
		.mem_address(p1_address),
		.mem_data(p1_data),
		.mem_req(p1_req),
		.mem_ready(p1_ready));
		
wire d_cache_miss;
wire IO_WC;
wire IO_RC;
wire IO_n_LB_w;
wire IO_n_LB_r;
wire[15:0] data_address;
wire[7:0] to_CPU_right;
wire[7:0] from_CPU_right;
wire[12:0] p2_address;
wire[63:0] p2_from_mem;
wire[63:0] p2_to_mem;
wire p2_reset;
wire p2_flush;
wire p2_req;
wire p2_wren;
wire p2_ready;

d_cache d_cache_inst(
		.clk(clk),
		.rst(p2_reset | button_s[3]),
		.flush(p2_flush),
		.d_cache_miss(d_cache_miss),
		.CPU_wren(IO_WC & IO_n_LB_w),
		.CPU_ren(IO_RC & IO_n_LB_r),
		.CPU_address(data_address),
		.to_CPU(to_CPU_right),
		.from_CPU(from_CPU_right),
		.mem_address(p2_address),
		.from_mem(p2_from_mem),
		.to_mem(p2_to_mem),
		.mem_req(p2_req),
		.mem_wren(p2_wren),
		.mem_ready(p2_ready));

wire[1:0] p1_page;
wire[2:0] p2_page;
wire init_req;
wire init_ready;
wire[15:0] init_data;

wire[17:0] SRAM_A;
wire[15:0] from_SRAM;
wire[15:0] to_SRAM;
wire SRAM_nWE;

SRAM_controller_internal SRAM_control_inst(
		.clk(clk),
		.rst(button_s[1] | ~reset),
		.p1_address(p1_address),
		.p1_page(p1_page),
		.p1_data(p1_data),
		.p1_req(p1_req),
		.p1_ready(p1_ready),
		.p2_address(p2_address),
		.p2_page(p2_page),
		.p2_to_mem(p2_to_mem),
		.p2_from_mem(p2_from_mem),
		.p2_req(p2_req),
		.p2_wren(p2_wren),
		.p2_ready(p2_ready),
		.SRAM_A(SRAM_A),
		.from_SRAM(from_SRAM),
		.to_SRAM(to_SRAM),
		.SRAM_nWE(SRAM_nWE),
		.init_req(init_req),
		.init_ready(init_ready),
		.init_data(init_data));
		
SRAM_internal SRAM_internal_inst(.clka(clk), .wea(~SRAM_nWE), .addra(SRAM_A[14:0]), .dina(to_SRAM), .douta(from_SRAM));
		
//####### ROM #################################################################
reg ROM_ready;
always @(posedge clk)
begin
	ROM_ready <= init_req;
end
assign init_ready = ROM_ready;
	PRG_ROM PRG_inst(.addra(SRAM_A[11:0]), .clka(clk), .douta(init_data));
//############################################################################

wire[7:0] from_CPU_left;
wire[7:0] to_CPU_left;

//####### LED Control ########################################################
reg[4:0] LED_reg;
assign LED = LED_reg ^ {~reset, button_s};

initial
begin
	LED_reg = 5'b00001;
end

always @(posedge clk)
begin
	button_s <= ~button;
	if(&data_address[15:2] && ~data_address[1] && ~IO_n_LB_w && IO_WC)
		LED_reg <= from_CPU_left[7:3];
end
//#############################################################################

wire IO_wren;
wire IO_ren;
assign IO_wren = (~IO_n_LB_w & IO_WC);
assign IO_ren = (~IO_n_LB_r & IO_RC);

//####### Serial Module #######################################################
wire serial_en;
wire[7:0] from_serial;
assign serial_en = &data_address[15:1];

serial serial_inst(
		.clk(clk),
		.reset(~reset),
		.A(data_address[0]),
		.CE(serial_en),
		.WREN(IO_wren),
		.REN(IO_ren),
		.rx(RXD),
		.tx(TXD),
		.to_CPU(from_serial),
		.from_CPU(from_CPU_left));
//#############################################################################

//####### Memory Subsystem Control ############################################
wire MSC_en;
assign MSC_en = &data_address[15:3] && ~data_address[2] && IO_wren;

MSC MSC_inst(
		.clk(clk),
		.rst(~reset),
		.wren(MSC_en),
		.A(data_address[1:0]),
		.data(from_CPU_left[3:0]),
		.p1_page(p1_page),
		.p2_page(p2_page),
		.p1_reset(p1_reset),
		.p2_reset(p2_reset),
		.p2_flush(p2_flush));
//#############################################################################

//####### VGA Module ##########################################################
wire VGA_MS;
wire VGA_En;
wire VGA_WrEn;
wire[7:0] from_VGA;
assign VGA_MS = (&data_address[15:4]) & (~data_address[3]) & (&data_address[2:1]) & IO_wren;
assign VGA_En = ~(|data_address[15:12]);
assign VGA_WrEn = VGA_En & IO_wren;

VGA VGA_inst(
        .clk_sys(clk),
        .clk_25(clk),
        .rst(~reset),
        .VGA_MS(VGA_MS),
        .VGA_WrEn(VGA_WrEn),
        .VGA_Din(from_CPU_left),
        .VGA_A(data_address[11:0]),
        .VGA_Dout(from_VGA),
        .R(R), .G(G), .B(B),
        .HSYNC(HSYNC), .VSYNC(VSYNC));
//#############################################################################

assign to_CPU_left = VGA_En ? from_VGA : from_serial;

RIPTIDE_II CPU_inst(
		.clk(clk),
		.n_halt(~button_s[0]),
		.p_cache_miss(p_cache_miss),
		.d_cache_miss(d_cache_miss),
		.n_reset(reset),
		.I(PRG_data),
		.A(PRG_address),
		.address(data_address),
		.data_out({from_CPU_left, from_CPU_right}),
		.data_in({to_CPU_left, to_CPU_right}),
		.IO_WC(IO_WC),
		.IO_RC(IO_RC),
		.IO_n_LB_w(IO_n_LB_w),
		.IO_n_LB_r(IO_n_LB_r));
endmodule
